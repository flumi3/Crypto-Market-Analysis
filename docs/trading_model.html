<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.4" />
<title>trading_model API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.18.1/highlight.min.js" integrity="sha256-eOgo0OtLL4cdq7RdwRUiGKLX9XsIJ7nGhWEKbohmVAQ=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>trading_model</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pandas as pd  # Library for data analyzing
import plotly.graph_objs as go  # Library for data visualizing

from pyti.smoothed_moving_average import smoothed_moving_average as sma  # Technical indicator library
from plotly.offline import plot  # Library for visualizing data
from binance import BinanceOperations
from strategies import Strategies


# This class holds all the properties and methods needed for the trading bot
class TradingModel:
    &#34;&#34;&#34;
    This class represents the trading model. It is able for processing the accessed market data as well as plotting and
    also for performing a backtest to see whether the chosen strategy would have been successful.
    &#34;&#34;&#34;

    # Constructor
    def __init__(self, symbol):
        self.symbol = symbol

    # This method processes the candlestick data
    @staticmethod
    def process_data(candlestick_data):
        &#34;&#34;&#34;
        Processes the candlestick data in order to be able to apply our trading strategy on it.

        First, we will rename the columns of our data frame and convert all data types from string to floats in order
        to be able to perform calculations. Then, we will add the slow moving average and the fast moving average to our
        market data. Each of them will represent a new column within our candlestick df. At last, we will another
        additional column holding the time in datetime format so we not only have the time or our data in timestamp
        format.

        Parameter:
            - candlestick_data: DataFrame - Candlestick market data that we will process

        Return:
            - df: DataFrame - The adjusted and processed candlestick data frame holding our market data
        &#34;&#34;&#34;
        df = candlestick_data
        df = df.drop(range(6, 12), axis=1)  # Drop the last six columns as they are not needed

        # Rename the columns
        col_names = [
            &#34;time&#34;,
            &#34;open&#34;,
            &#34;high&#34;,
            &#34;low&#34;,
            &#34;close&#34;,
            &#34;volume&#34;
        ]
        df.columns = col_names

        # Cast values from strings to floats
        for col in col_names:
            df[col] = df[col].astype(float)

        # Add the moving averages to the data frame
        df[&#34;fast_sma&#34;] = sma(df[&#34;close&#34;].tolist(), 10)  # fast simple moving average follows prices closely
        df[&#34;slow_sma&#34;] = sma(df[&#34;close&#34;].tolist(), 30)  # slow simple moving average follows prices less closely

        # Add date in datetime format to the data frame so we can se real dates on the plot and not just timestamps
        df[&#34;datetime&#34;] = pd.to_datetime(df[&#34;time&#34;] * 1000000, infer_datetime_format=True)

        # Return result
        return df

    # This method visualizes the candlestick data in form of a candlestick chart
    def plot_data(self, candlestick_df, buy_signals, sell_signals):
        &#34;&#34;&#34;
        Plots the candlestick data as html chart.

        It will contain all candlesticks, the moving averages and also our buying and selling points.

        Parameter:
            - candlestick_df: DataFrame - The market data that we will visualize
            - buy_signals: list - List of buy signals
            - sell_signals: list - List of sell signals

        Return:
            - None
        &#34;&#34;&#34;
        df = candlestick_df

        # Plot candlestick chart
        candle = go.Candlestick(
            x=df[&#34;datetime&#34;],
            open=df[&#34;open&#34;],
            close=df[&#34;close&#34;],
            high=df[&#34;high&#34;],
            low=df[&#34;low&#34;],
            name=&#34;Candlesticks&#34;
        )

        # Plot fast simple moving average
        fast_sma = go.Scatter(
            x=df[&#34;datetime&#34;],
            y=df[&#34;fast_sma&#34;],
            name=&#34;Fast SMA&#34;,
            line=dict(color=&#34;rgba(102, 207, 255, 50)&#34;)
        )

        # Plot slow moving average
        slow_sma = go.Scatter(
            x=df[&#34;datetime&#34;],
            y=df[&#34;slow_sma&#34;],
            name=&#34;Slow SMA&#34;,
            line=dict(color=&#34;rgba(255, 207, 102, 50)&#34;)
        )

        # Plot buy signals
        buys = go.Scatter(
            x=[time[0] for time in buy_signals],
            y=[price[1] for price in buy_signals],
            name=&#34;Buy Signals&#34;,
            mode=&#34;markers&#34;
        )

        # Plot desired selling prices
        desired_prices = go.Scatter(
            x=[time[0] for time in buy_signals],
            y=[price[1] * 1.02 for price in buy_signals],
            name=&#34;Desired Sell Prices&#34;,
            mode=&#34;markers&#34;
        )

        # Plot selling signals
        sells = go.Scatter(
            x=[time[0] for time in sell_signals],
            y=[price[2] for price in sell_signals],
            name=&#34;Sell Signals&#34;,
            mode=&#34;markers&#34;,
            marker=dict(
                color=&#34;rgb(139,69,19)&#34;
            )
        )

        # List of objects that shall be plotted
        data = [candle, slow_sma, fast_sma, buys, desired_prices, sells]

        # Style and display
        layout = go.Layout(
            title=self.symbol,
            xaxis_title=&#34;Time&#34;,
            yaxis_title=&#34;Euro&#34;
        )

        # Create figure and plot it
        figure = go.Figure(data=data, layout=layout)
        plot(figure, filename=self.symbol + &#34;.html&#34;)

    # This method backtests the strategy
    def backtest_strategy(self, buy_signals, sell_signals):
        &#34;&#34;&#34;
        Performs a backtest on passed buy and sell signals to see whether the strategy would have been successful.

        Information that will be calculated:
            - Coins bought
            - Coins sold
            - Average buying price
            - Average selling price
            - Total money spent
            - Total money earnt
            - Profit

        Parameter:
            - buy_signals: list - List of buy signals
            - sell_signals: list - List of sell signals

        Return:
            - None
        &#34;&#34;&#34;
        if not buy_signals:
            print(&#34;Market data did not match the strategy. No coins where bought.&#34;)
            return

        money_spent = 0
        money_earned = 0

        # Add all buying and selling prices
        quantity = 0
        for signal in sell_signals:
            # [time, buying_price, selling_price, index, quantity]
            quantity = signal[4]
            buying_price = signal[1] * quantity
            selling_price = signal[2] * quantity

            # Calculate spent and earned money
            money_spent = money_spent + buying_price
            money_earned = money_earned + selling_price

        # Calculate some other stats
        profit = money_earned - money_spent
        coins_bought = len(buy_signals) * quantity
        coins_sold = len(sell_signals) * quantity
        average_buying_price = money_spent / coins_bought
        average_selling_price = money_earned / coins_bought

        # Output
        print(f&#34;Symbol: {self.symbol}&#34;)
        print(&#34;&#34;)

        print(f&#34;Coins bought: {coins_bought}&#34;)
        print(f&#34;Coins sold: {coins_sold}&#34;)
        print(&#34;&#34;)

        print(f&#34;Average buying price: {round(average_buying_price, 2)}€&#34;)
        print(f&#34;Average selling price: {round(average_selling_price, 2)}€&#34;)
        print(&#34;&#34;)

        print(f&#34;Total money spent: {round(money_spent, 2)}€&#34;)
        print(f&#34;Total money earned: {round(money_earned, 2)}€&#34;)
        print(&#34;&#34;)

        print(f&#34;Profit: {round(profit, 2)}€&#34;)

    # This method executes the actual operations of the bot
    def run_moving_average_strategy(self):
        &#34;&#34;&#34;
        This method will run the moving average strategy.

        It will call our other methods to:
            - get the candlestick data
            - process the candlestick data
            - compute the buy and sell signals
            - backtest the strategy
            - plot the candlestick chart

        Parameter:

        Return:
            - None
        &#34;&#34;&#34;
        binance = BinanceOperations()  # Create instance of binance operations class
        strategies = Strategies()  # Create instance of strategies class

        # Get candlestick data (with good dates to see signals, for test reasons)
        # start_time = 1590624000000  # 28th of May 2020
        # end_time = 1593302400000  # 28th of June 2020
        # candlestick_data = binance.get_candlestick_data(self.symbol, start_time=start_time, end_time=end_time)

        # Get candlestick data
        candlestick_data = binance.get_candlestick_data(self.symbol)

        # Process the candlestick data
        candlestick_df = self.process_data(candlestick_data)

        # Compute buy and sell signals:
        signals = strategies.moving_average_strategy(candlestick_df, quantity=1)
        buy_signals = signals[0]
        sell_signals = signals[1]

        # Backtest the strategy
        self.backtest_strategy(buy_signals, sell_signals)

        # Plot the candlestick data as candlestick chart
        self.plot_data(candlestick_df, buy_signals, sell_signals)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="trading_model.TradingModel"><code class="flex name class">
<span>class <span class="ident">TradingModel</span></span>
<span>(</span><span>symbol)</span>
</code></dt>
<dd>
<div class="desc"><p>This class represents the trading model. It is able for processing the accessed market data as well as plotting and
also for performing a backtest to see whether the chosen strategy would have been successful.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TradingModel:
    &#34;&#34;&#34;
    This class represents the trading model. It is able for processing the accessed market data as well as plotting and
    also for performing a backtest to see whether the chosen strategy would have been successful.
    &#34;&#34;&#34;

    # Constructor
    def __init__(self, symbol):
        self.symbol = symbol

    # This method processes the candlestick data
    @staticmethod
    def process_data(candlestick_data):
        &#34;&#34;&#34;
        Processes the candlestick data in order to be able to apply our trading strategy on it.

        First, we will rename the columns of our data frame and convert all data types from string to floats in order
        to be able to perform calculations. Then, we will add the slow moving average and the fast moving average to our
        market data. Each of them will represent a new column within our candlestick df. At last, we will another
        additional column holding the time in datetime format so we not only have the time or our data in timestamp
        format.

        Parameter:
            - candlestick_data: DataFrame - Candlestick market data that we will process

        Return:
            - df: DataFrame - The adjusted and processed candlestick data frame holding our market data
        &#34;&#34;&#34;
        df = candlestick_data
        df = df.drop(range(6, 12), axis=1)  # Drop the last six columns as they are not needed

        # Rename the columns
        col_names = [
            &#34;time&#34;,
            &#34;open&#34;,
            &#34;high&#34;,
            &#34;low&#34;,
            &#34;close&#34;,
            &#34;volume&#34;
        ]
        df.columns = col_names

        # Cast values from strings to floats
        for col in col_names:
            df[col] = df[col].astype(float)

        # Add the moving averages to the data frame
        df[&#34;fast_sma&#34;] = sma(df[&#34;close&#34;].tolist(), 10)  # fast simple moving average follows prices closely
        df[&#34;slow_sma&#34;] = sma(df[&#34;close&#34;].tolist(), 30)  # slow simple moving average follows prices less closely

        # Add date in datetime format to the data frame so we can se real dates on the plot and not just timestamps
        df[&#34;datetime&#34;] = pd.to_datetime(df[&#34;time&#34;] * 1000000, infer_datetime_format=True)

        # Return result
        return df

    # This method visualizes the candlestick data in form of a candlestick chart
    def plot_data(self, candlestick_df, buy_signals, sell_signals):
        &#34;&#34;&#34;
        Plots the candlestick data as html chart.

        It will contain all candlesticks, the moving averages and also our buying and selling points.

        Parameter:
            - candlestick_df: DataFrame - The market data that we will visualize
            - buy_signals: list - List of buy signals
            - sell_signals: list - List of sell signals

        Return:
            - None
        &#34;&#34;&#34;
        df = candlestick_df

        # Plot candlestick chart
        candle = go.Candlestick(
            x=df[&#34;datetime&#34;],
            open=df[&#34;open&#34;],
            close=df[&#34;close&#34;],
            high=df[&#34;high&#34;],
            low=df[&#34;low&#34;],
            name=&#34;Candlesticks&#34;
        )

        # Plot fast simple moving average
        fast_sma = go.Scatter(
            x=df[&#34;datetime&#34;],
            y=df[&#34;fast_sma&#34;],
            name=&#34;Fast SMA&#34;,
            line=dict(color=&#34;rgba(102, 207, 255, 50)&#34;)
        )

        # Plot slow moving average
        slow_sma = go.Scatter(
            x=df[&#34;datetime&#34;],
            y=df[&#34;slow_sma&#34;],
            name=&#34;Slow SMA&#34;,
            line=dict(color=&#34;rgba(255, 207, 102, 50)&#34;)
        )

        # Plot buy signals
        buys = go.Scatter(
            x=[time[0] for time in buy_signals],
            y=[price[1] for price in buy_signals],
            name=&#34;Buy Signals&#34;,
            mode=&#34;markers&#34;
        )

        # Plot desired selling prices
        desired_prices = go.Scatter(
            x=[time[0] for time in buy_signals],
            y=[price[1] * 1.02 for price in buy_signals],
            name=&#34;Desired Sell Prices&#34;,
            mode=&#34;markers&#34;
        )

        # Plot selling signals
        sells = go.Scatter(
            x=[time[0] for time in sell_signals],
            y=[price[2] for price in sell_signals],
            name=&#34;Sell Signals&#34;,
            mode=&#34;markers&#34;,
            marker=dict(
                color=&#34;rgb(139,69,19)&#34;
            )
        )

        # List of objects that shall be plotted
        data = [candle, slow_sma, fast_sma, buys, desired_prices, sells]

        # Style and display
        layout = go.Layout(
            title=self.symbol,
            xaxis_title=&#34;Time&#34;,
            yaxis_title=&#34;Euro&#34;
        )

        # Create figure and plot it
        figure = go.Figure(data=data, layout=layout)
        plot(figure, filename=self.symbol + &#34;.html&#34;)

    # This method backtests the strategy
    def backtest_strategy(self, buy_signals, sell_signals):
        &#34;&#34;&#34;
        Performs a backtest on passed buy and sell signals to see whether the strategy would have been successful.

        Information that will be calculated:
            - Coins bought
            - Coins sold
            - Average buying price
            - Average selling price
            - Total money spent
            - Total money earnt
            - Profit

        Parameter:
            - buy_signals: list - List of buy signals
            - sell_signals: list - List of sell signals

        Return:
            - None
        &#34;&#34;&#34;
        if not buy_signals:
            print(&#34;Market data did not match the strategy. No coins where bought.&#34;)
            return

        money_spent = 0
        money_earned = 0

        # Add all buying and selling prices
        quantity = 0
        for signal in sell_signals:
            # [time, buying_price, selling_price, index, quantity]
            quantity = signal[4]
            buying_price = signal[1] * quantity
            selling_price = signal[2] * quantity

            # Calculate spent and earned money
            money_spent = money_spent + buying_price
            money_earned = money_earned + selling_price

        # Calculate some other stats
        profit = money_earned - money_spent
        coins_bought = len(buy_signals) * quantity
        coins_sold = len(sell_signals) * quantity
        average_buying_price = money_spent / coins_bought
        average_selling_price = money_earned / coins_bought

        # Output
        print(f&#34;Symbol: {self.symbol}&#34;)
        print(&#34;&#34;)

        print(f&#34;Coins bought: {coins_bought}&#34;)
        print(f&#34;Coins sold: {coins_sold}&#34;)
        print(&#34;&#34;)

        print(f&#34;Average buying price: {round(average_buying_price, 2)}€&#34;)
        print(f&#34;Average selling price: {round(average_selling_price, 2)}€&#34;)
        print(&#34;&#34;)

        print(f&#34;Total money spent: {round(money_spent, 2)}€&#34;)
        print(f&#34;Total money earned: {round(money_earned, 2)}€&#34;)
        print(&#34;&#34;)

        print(f&#34;Profit: {round(profit, 2)}€&#34;)

    # This method executes the actual operations of the bot
    def run_moving_average_strategy(self):
        &#34;&#34;&#34;
        This method will run the moving average strategy.

        It will call our other methods to:
            - get the candlestick data
            - process the candlestick data
            - compute the buy and sell signals
            - backtest the strategy
            - plot the candlestick chart

        Parameter:

        Return:
            - None
        &#34;&#34;&#34;
        binance = BinanceOperations()  # Create instance of binance operations class
        strategies = Strategies()  # Create instance of strategies class

        # Get candlestick data (with good dates to see signals, for test reasons)
        # start_time = 1590624000000  # 28th of May 2020
        # end_time = 1593302400000  # 28th of June 2020
        # candlestick_data = binance.get_candlestick_data(self.symbol, start_time=start_time, end_time=end_time)

        # Get candlestick data
        candlestick_data = binance.get_candlestick_data(self.symbol)

        # Process the candlestick data
        candlestick_df = self.process_data(candlestick_data)

        # Compute buy and sell signals:
        signals = strategies.moving_average_strategy(candlestick_df, quantity=1)
        buy_signals = signals[0]
        sell_signals = signals[1]

        # Backtest the strategy
        self.backtest_strategy(buy_signals, sell_signals)

        # Plot the candlestick data as candlestick chart
        self.plot_data(candlestick_df, buy_signals, sell_signals)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="trading_model.TradingModel.process_data"><code class="name flex">
<span>def <span class="ident">process_data</span></span>(<span>candlestick_data)</span>
</code></dt>
<dd>
<div class="desc"><p>Processes the candlestick data in order to be able to apply our trading strategy on it.</p>
<p>First, we will rename the columns of our data frame and convert all data types from string to floats in order
to be able to perform calculations. Then, we will add the slow moving average and the fast moving average to our
market data. Each of them will represent a new column within our candlestick df. At last, we will another
additional column holding the time in datetime format so we not only have the time or our data in timestamp
format.</p>
<h2 id="parameter">Parameter</h2>
<ul>
<li>candlestick_data: DataFrame - Candlestick market data that we will process</li>
</ul>
<h2 id="return">Return</h2>
<ul>
<li>df: DataFrame - The adjusted and processed candlestick data frame holding our market data</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def process_data(candlestick_data):
    &#34;&#34;&#34;
    Processes the candlestick data in order to be able to apply our trading strategy on it.

    First, we will rename the columns of our data frame and convert all data types from string to floats in order
    to be able to perform calculations. Then, we will add the slow moving average and the fast moving average to our
    market data. Each of them will represent a new column within our candlestick df. At last, we will another
    additional column holding the time in datetime format so we not only have the time or our data in timestamp
    format.

    Parameter:
        - candlestick_data: DataFrame - Candlestick market data that we will process

    Return:
        - df: DataFrame - The adjusted and processed candlestick data frame holding our market data
    &#34;&#34;&#34;
    df = candlestick_data
    df = df.drop(range(6, 12), axis=1)  # Drop the last six columns as they are not needed

    # Rename the columns
    col_names = [
        &#34;time&#34;,
        &#34;open&#34;,
        &#34;high&#34;,
        &#34;low&#34;,
        &#34;close&#34;,
        &#34;volume&#34;
    ]
    df.columns = col_names

    # Cast values from strings to floats
    for col in col_names:
        df[col] = df[col].astype(float)

    # Add the moving averages to the data frame
    df[&#34;fast_sma&#34;] = sma(df[&#34;close&#34;].tolist(), 10)  # fast simple moving average follows prices closely
    df[&#34;slow_sma&#34;] = sma(df[&#34;close&#34;].tolist(), 30)  # slow simple moving average follows prices less closely

    # Add date in datetime format to the data frame so we can se real dates on the plot and not just timestamps
    df[&#34;datetime&#34;] = pd.to_datetime(df[&#34;time&#34;] * 1000000, infer_datetime_format=True)

    # Return result
    return df</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="trading_model.TradingModel.backtest_strategy"><code class="name flex">
<span>def <span class="ident">backtest_strategy</span></span>(<span>self, buy_signals, sell_signals)</span>
</code></dt>
<dd>
<div class="desc"><p>Performs a backtest on passed buy and sell signals to see whether the strategy would have been successful.</p>
<p>Information that will be calculated:
- Coins bought
- Coins sold
- Average buying price
- Average selling price
- Total money spent
- Total money earnt
- Profit</p>
<h2 id="parameter">Parameter</h2>
<ul>
<li>buy_signals: list - List of buy signals</li>
<li>sell_signals: list - List of sell signals</li>
</ul>
<h2 id="return">Return</h2>
<ul>
<li>None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def backtest_strategy(self, buy_signals, sell_signals):
    &#34;&#34;&#34;
    Performs a backtest on passed buy and sell signals to see whether the strategy would have been successful.

    Information that will be calculated:
        - Coins bought
        - Coins sold
        - Average buying price
        - Average selling price
        - Total money spent
        - Total money earnt
        - Profit

    Parameter:
        - buy_signals: list - List of buy signals
        - sell_signals: list - List of sell signals

    Return:
        - None
    &#34;&#34;&#34;
    if not buy_signals:
        print(&#34;Market data did not match the strategy. No coins where bought.&#34;)
        return

    money_spent = 0
    money_earned = 0

    # Add all buying and selling prices
    quantity = 0
    for signal in sell_signals:
        # [time, buying_price, selling_price, index, quantity]
        quantity = signal[4]
        buying_price = signal[1] * quantity
        selling_price = signal[2] * quantity

        # Calculate spent and earned money
        money_spent = money_spent + buying_price
        money_earned = money_earned + selling_price

    # Calculate some other stats
    profit = money_earned - money_spent
    coins_bought = len(buy_signals) * quantity
    coins_sold = len(sell_signals) * quantity
    average_buying_price = money_spent / coins_bought
    average_selling_price = money_earned / coins_bought

    # Output
    print(f&#34;Symbol: {self.symbol}&#34;)
    print(&#34;&#34;)

    print(f&#34;Coins bought: {coins_bought}&#34;)
    print(f&#34;Coins sold: {coins_sold}&#34;)
    print(&#34;&#34;)

    print(f&#34;Average buying price: {round(average_buying_price, 2)}€&#34;)
    print(f&#34;Average selling price: {round(average_selling_price, 2)}€&#34;)
    print(&#34;&#34;)

    print(f&#34;Total money spent: {round(money_spent, 2)}€&#34;)
    print(f&#34;Total money earned: {round(money_earned, 2)}€&#34;)
    print(&#34;&#34;)

    print(f&#34;Profit: {round(profit, 2)}€&#34;)</code></pre>
</details>
</dd>
<dt id="trading_model.TradingModel.plot_data"><code class="name flex">
<span>def <span class="ident">plot_data</span></span>(<span>self, candlestick_df, buy_signals, sell_signals)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots the candlestick data as html chart.</p>
<p>It will contain all candlesticks, the moving averages and also our buying and selling points.</p>
<h2 id="parameter">Parameter</h2>
<ul>
<li>candlestick_df: DataFrame - The market data that we will visualize</li>
<li>buy_signals: list - List of buy signals</li>
<li>sell_signals: list - List of sell signals</li>
</ul>
<h2 id="return">Return</h2>
<ul>
<li>None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_data(self, candlestick_df, buy_signals, sell_signals):
    &#34;&#34;&#34;
    Plots the candlestick data as html chart.

    It will contain all candlesticks, the moving averages and also our buying and selling points.

    Parameter:
        - candlestick_df: DataFrame - The market data that we will visualize
        - buy_signals: list - List of buy signals
        - sell_signals: list - List of sell signals

    Return:
        - None
    &#34;&#34;&#34;
    df = candlestick_df

    # Plot candlestick chart
    candle = go.Candlestick(
        x=df[&#34;datetime&#34;],
        open=df[&#34;open&#34;],
        close=df[&#34;close&#34;],
        high=df[&#34;high&#34;],
        low=df[&#34;low&#34;],
        name=&#34;Candlesticks&#34;
    )

    # Plot fast simple moving average
    fast_sma = go.Scatter(
        x=df[&#34;datetime&#34;],
        y=df[&#34;fast_sma&#34;],
        name=&#34;Fast SMA&#34;,
        line=dict(color=&#34;rgba(102, 207, 255, 50)&#34;)
    )

    # Plot slow moving average
    slow_sma = go.Scatter(
        x=df[&#34;datetime&#34;],
        y=df[&#34;slow_sma&#34;],
        name=&#34;Slow SMA&#34;,
        line=dict(color=&#34;rgba(255, 207, 102, 50)&#34;)
    )

    # Plot buy signals
    buys = go.Scatter(
        x=[time[0] for time in buy_signals],
        y=[price[1] for price in buy_signals],
        name=&#34;Buy Signals&#34;,
        mode=&#34;markers&#34;
    )

    # Plot desired selling prices
    desired_prices = go.Scatter(
        x=[time[0] for time in buy_signals],
        y=[price[1] * 1.02 for price in buy_signals],
        name=&#34;Desired Sell Prices&#34;,
        mode=&#34;markers&#34;
    )

    # Plot selling signals
    sells = go.Scatter(
        x=[time[0] for time in sell_signals],
        y=[price[2] for price in sell_signals],
        name=&#34;Sell Signals&#34;,
        mode=&#34;markers&#34;,
        marker=dict(
            color=&#34;rgb(139,69,19)&#34;
        )
    )

    # List of objects that shall be plotted
    data = [candle, slow_sma, fast_sma, buys, desired_prices, sells]

    # Style and display
    layout = go.Layout(
        title=self.symbol,
        xaxis_title=&#34;Time&#34;,
        yaxis_title=&#34;Euro&#34;
    )

    # Create figure and plot it
    figure = go.Figure(data=data, layout=layout)
    plot(figure, filename=self.symbol + &#34;.html&#34;)</code></pre>
</details>
</dd>
<dt id="trading_model.TradingModel.run_moving_average_strategy"><code class="name flex">
<span>def <span class="ident">run_moving_average_strategy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>This method will run the moving average strategy.</p>
<p>It will call our other methods to:
- get the candlestick data
- process the candlestick data
- compute the buy and sell signals
- backtest the strategy
- plot the candlestick chart</p>
<p>Parameter:</p>
<h2 id="return">Return</h2>
<ul>
<li>None</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_moving_average_strategy(self):
    &#34;&#34;&#34;
    This method will run the moving average strategy.

    It will call our other methods to:
        - get the candlestick data
        - process the candlestick data
        - compute the buy and sell signals
        - backtest the strategy
        - plot the candlestick chart

    Parameter:

    Return:
        - None
    &#34;&#34;&#34;
    binance = BinanceOperations()  # Create instance of binance operations class
    strategies = Strategies()  # Create instance of strategies class

    # Get candlestick data (with good dates to see signals, for test reasons)
    # start_time = 1590624000000  # 28th of May 2020
    # end_time = 1593302400000  # 28th of June 2020
    # candlestick_data = binance.get_candlestick_data(self.symbol, start_time=start_time, end_time=end_time)

    # Get candlestick data
    candlestick_data = binance.get_candlestick_data(self.symbol)

    # Process the candlestick data
    candlestick_df = self.process_data(candlestick_data)

    # Compute buy and sell signals:
    signals = strategies.moving_average_strategy(candlestick_df, quantity=1)
    buy_signals = signals[0]
    sell_signals = signals[1]

    # Backtest the strategy
    self.backtest_strategy(buy_signals, sell_signals)

    # Plot the candlestick data as candlestick chart
    self.plot_data(candlestick_df, buy_signals, sell_signals)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="trading_model.TradingModel" href="#trading_model.TradingModel">TradingModel</a></code></h4>
<ul class="">
<li><code><a title="trading_model.TradingModel.backtest_strategy" href="#trading_model.TradingModel.backtest_strategy">backtest_strategy</a></code></li>
<li><code><a title="trading_model.TradingModel.plot_data" href="#trading_model.TradingModel.plot_data">plot_data</a></code></li>
<li><code><a title="trading_model.TradingModel.process_data" href="#trading_model.TradingModel.process_data">process_data</a></code></li>
<li><code><a title="trading_model.TradingModel.run_moving_average_strategy" href="#trading_model.TradingModel.run_moving_average_strategy">run_moving_average_strategy</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.4</a>.</p>
</footer>
</body>
</html>